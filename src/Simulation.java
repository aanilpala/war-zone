
import java.io.File;
import java.io.IOException;
import java.util.Random;
import java.util.Scanner;
import java.util.Vector;

//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Untitled
//  @ File Name : Simulation.java
//  @ Date : 3/29/2013
//  @ Author : 
//
//




public class Simulation {
	public int zoneWidth;
	public int zoneHeight;
	private int numberOfClutters;
	private WeakClutterFactory weakClutterFactory;
	private SturdyClutterFactory sturdyClutterFactory;
	public Vector<RoboFighter> roboFighters;
	public Vector<Clutter> clutters;
	public Vector<Projectile> projectiles;
	public Random randomGenerator;
	private int stepsToFirePeriodicEvents;
	public int totalSteps;
	public int projectileMaxCoefficient; // defines how many times faster can a projectile displace than a robofighter at most.
	
	public Legend legend;
	public Vector<String> legendNotifications;
	public RoboFighter leadingRobot;
	public int totalDamage;
	public int totalKilled;
	
	boolean[] inputArray;
	
	
	public Simulation() {
		
		totalSteps = 0;
		
		weakClutterFactory = new WeakClutterFactory(this);
		sturdyClutterFactory = new SturdyClutterFactory(this);
		randomGenerator = new Random();
		roboFighters = new Vector<RoboFighter>();
		clutters = new Vector<Clutter>();
		projectiles = new Vector<Projectile>();
		legendNotifications = new Vector<String>();
		
		totalKilled = 0;
		totalDamage = 0;
		leadingRobot = null;
		inputArray = new boolean[256];
		
		for(int ctr = 0; ctr < 256; ctr++) inputArray[ctr] = false;
		
		
		try {
			getWarZoneSpecs("config.txt");
			getRoboFighterSpecs("config.txt");
		}
		catch (IOException e){
			e.printStackTrace();
		}
		
		for(int ctr = 0; ctr < numberOfClutters; ctr++) {
			if(randomGenerator.nextBoolean()) addClutter(1, sturdyClutterFactory);
			else addClutter(1, weakClutterFactory);
		}
		
	}
	
	public void step(double deltaTime) {
	
		/*for(Clutter each : clutters) {
			each.step(deltaTime);
		}*/
		
		for(Projectile each : projectiles) {
			each.step(deltaTime);
		}
		
		for(RoboFighter each : roboFighters) {
			each.step(deltaTime);
		}
		
		cleanPassives();
		
		if((totalSteps % stepsToFirePeriodicEvents) == 0) firePeriodicEvents();
		boolean ammunitionFinished = true;
		
		for(RoboFighter each : roboFighters) {
			if(leadingRobot == null || each.indStrength > leadingRobot.indStrength) leadingRobot = each;
			if(each.ammunition > 0) ammunitionFinished = false; 
		}
	
		if(leadingRobot != null && ammunitionFinished) this.legendNotifications.add(Legend.generateWinNotification(leadingRobot));
		
		//legend.updateWarZoneData();
		
		totalSteps++;
	}
	
	private void cleanPassives() {
		
		for(int ctr = 0; ctr < clutters.size(); ctr++) {
			Clutter each = clutters.get(ctr);
			if(!each.isActive) clutters.remove(ctr--);
		}
		
		
		for(int ctr = 0; ctr < projectiles.size(); ctr++) {
			Projectile each = projectiles.get(ctr);
			if(!each.isActive) projectiles.remove(ctr--);
		}
		
		for(int ctr = 0; ctr < roboFighters.size(); ctr++) {
			RoboFighter each = roboFighters.get(ctr);
			if(!each.isActive) roboFighters.remove(ctr--);
		}
	
	}

	public void addClutter(int quantity, ClutterFactory f) {
		
		for(int ctr = 0; ctr < quantity; ctr++) {
			clutters.add(f.createClutter());
		}
		
	}
	
	private void getWarZoneSpecs(String fileName) throws IOException {
		Scanner sc = new Scanner(new File(fileName));
		sc.findWithinHorizon("#WarZone", 0);
		zoneWidth = sc.nextInt();
		zoneHeight = sc.nextInt();
		
		legend = new Legend(sc.nextInt(), sc.nextInt(), this);
		
		numberOfClutters = sc.nextInt();
		
		weakClutterFactory.minStrength = sc.nextInt();
		weakClutterFactory.maxStrength  = sc.nextInt();
		WeakClutterFactory.radius = sc.nextInt();
		
		sturdyClutterFactory.minStrength = sc.nextInt();
		sturdyClutterFactory.maxStrength = sc.nextInt();
		SturdyClutterFactory.radius = sc.nextInt();
		
		stepsToFirePeriodicEvents = sc.nextInt();
		
		projectileMaxCoefficient = sc.nextInt();
		
		BasicFighter.strength = sc.nextInt();
		HumanControlledFighter.strength = sc.nextInt(); 
		
		LowDamaged.threshold = sc.nextInt();
		MediumDamaged.threshold = sc.nextInt();
		HighDamaged.threshold = sc.nextInt();
		
		Projectile.proRadius = sc.nextInt();
		
		sc.close();
	}
	
	private void getRoboFighterSpecs(String fileName) throws IOException {
		int ammunition;
		int type;
		int radius;
		String name;
		
		Scanner sc = new Scanner(new File(fileName));
		sc.findWithinHorizon("#RoboFighters", 0);
		
		sc.nextLine();
		
		while(sc.hasNext()) {
			name = sc.next();
			type = sc.nextInt();
			radius = sc.nextInt();
			ammunition = sc.nextInt();
			
			if(type == 0) roboFighters.add(new BasicFighter(radius, name, ammunition, this));
			else if(type == 1) roboFighters.add(new HumanControlledFighter(radius, name, ammunition, this, 
					new KeyboardProfile(sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt(), sc.nextInt())));
			}
		
		sc.close();
	}
		
	private void firePeriodicEvents() {
			
		for(RoboFighter eachFighter: roboFighters) {
			if(eachFighter.isHuman == true) continue;
			if(randomGenerator.nextBoolean()) eachFighter.strategy = new SAggressive();
			else eachFighter.strategy = new SRandom();
		}
		
	}
}
