import java.awt.Color;
import java.awt.Graphics2D;

//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Untitled
//  @ File Name : Projectile.java
//  @ Date : 3/29/2013
//  @ Author : 
//
//




public class Projectile extends Entity {
	
	public int damagePower;
	public double stepDeltaX;
	public double stepDeltaY;
	public static int proRadius;
	public int speedCoeff;
	public Color color;
	public RoboFighter firedBy;
	
	public Projectile(double x, double y, double stepDeltaX, double stepDeltaY, Color color, Simulation simulation, RoboFighter firedBy) {
		super(proRadius, simulation);
		
		this.speedCoeff = simulation.randomGenerator.nextInt(simulation.projectileMaxCoefficient - 1) + 1;
		this.x = x;
		this.y = y;
		
		this.color = color;
		this.damagePower = 3;
		this.stepDeltaX = stepDeltaX;
		this.stepDeltaY = stepDeltaY;
		
		this.firedBy = firedBy;
	}

	@Override
	public void step(double deltaTime) {
		this.x += speedCoeff*stepDeltaX;
		this.y += speedCoeff*stepDeltaY;
		
		//if(x > simulation.zoneWidth || y > simulation.zoneHeight || x < 0 || y < 0)
		if(FightStrategy.insideCheck(x, y, simulation.zoneWidth, simulation.zoneWidth, radius) < 0) this.isActive = false; 
		if(FightStrategy.insideCheck(x, y, simulation.legend.width, simulation.legend.height, -1*radius) > 0) this.isActive = false;
		
		
		double distance;
		
		for(Clutter each : simulation.clutters) {
			distance = findDistance(each.x, this.x, each.y, this.y);
			if(distance < each.radius) {
				if(each.radius > 5) each.radius -= this.damagePower*each.radius/each.strength;
				
				each.damage += this.damagePower;
				each.strength -= this.damagePower;
				
				if(each.strength <= 0) 
					each.isActive = false;
				
				this.isActive = false;
				return;
			}
		}
		
		for(int ctr = 0; ctr < simulation.roboFighters.size(); ctr++) {
			RoboFighter each = simulation.roboFighters.get(ctr);
			distance = findDistance(each.x, this.x, each.y, this.y);
			
			
			
			if(distance < (each.radius)) {
				each.damage += this.damagePower;
				each.indStrength -= this.damagePower;
				simulation.totalDamage += damagePower;
				each.radius -= 3*this.damagePower*each.radius/(each.indStrength+each.damage);  // not sure it makes sim more realistic.
				//each.radius--;
				
				if(each.indStrength <= 0) {
					each.isActive = false;
					simulation.totalKilled += 1;
					simulation.legendNotifications.add(Legend.generateKillsNotification(this.firedBy, each));
					firedBy.kills++;
					
				}
				else if(each.indStrength <= LowDamaged.threshold && !(each instanceof DamageDecorator)) {
					each.isActive = false;
					//simulation.roboFighters.remove(each);
					each = new LowDamaged(each);
					simulation.roboFighters.add(each);
				}
				else if(each.indStrength <= MediumDamaged.threshold && each instanceof LowDamaged) {
					each.isActive = false;
					//simulation.roboFighters.remove(each);
					each = new MediumDamaged(each);
					simulation.roboFighters.add(each);
				}
				else if(each.indStrength <= HighDamaged.threshold && each instanceof MediumDamaged) {
					each.isActive = false;
					//simulation.roboFighters.remove(each);
					each = new HighDamaged(each);
					simulation.roboFighters.add(each);
				}
					
				//simulation.clutters.remove(each);
				this.isActive = false;
				return;
			}
		}
		
		
	}

	@Override
	public void draw(Graphics2D g2d) {
		g2d.setColor(this.color);
		super.draw(g2d);
		g2d.fillOval((int) x - radius,(int) y - radius, (int) 2*radius, (int) 2*radius); 
		
	}
	
	public static double findDistance(double x, double x2, double y, double y2) {
		return Math.sqrt((Math.pow((x-x2),2) + Math.pow((y-y2),2))); 
	}
	
}

