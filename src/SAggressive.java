
//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Untitled
//  @ File Name : SAggressive.java
//  @ Date : 3/29/2013
//  @ Author : 
//
//

public class SAggressive extends FightStrategy {
	
	public SAggressive() {
		super();
		this.stepsToFire = 45;
	}
	
	@Override
	public void move(RoboFighter r, double deltaTime) {
		
		//if(r.x <= r.radius || r.x >= r.simulation.zoneWidth - r.radius) stepDeltaX *= -1;
		//if(r.y <= r.radius || r.y >= r.simulation.zoneHeight - r.radius) stepDeltaY *= -1;
		
		int insCheck;
		
		insCheck = insideCheck(r.x, r.y, r.simulation.legend.width, r.simulation.legend.height, -1*r.radius);
		
		if(insCheck == 1) stepDeltaX *= -1;
		if(insCheck == 2) stepDeltaY *= -1;
		
		insCheck = insideCheck(r.x, r.y, r.simulation.zoneWidth, r.simulation.zoneHeight, r.radius);
		
		if(insCheck == -1) stepDeltaX *= -1;
		if(insCheck == -2) stepDeltaY *= -1;
		
		
		
		/*if(r.x <= r.radius || ((r.y <= r.simulation.legend.height + r.radius) && (r.x <= r.radius + r.simulation.legend.width))) 
			stepDeltaX *= -1;
		else if(r.x >= r.simulation.zoneWidth - r.radius) 
			stepDeltaX *= -1;
		else if(r.y <= r.radius || ((r.x <= r.simulation.legend.width + r.radius) && (r.y <= r.radius + r.simulation.legend.height))) 
			stepDeltaY *= -1;
		else if(r.y >= r.simulation.zoneHeight - r.radius) 
			stepDeltaY *= -1;*/
		
		r.x += deltaTime*stepDeltaX;
		r.y += deltaTime*stepDeltaY;
		
		avoidCollision(r.x, r.y, r);
		
		if((r.simulation.totalSteps % stepsToFire) == 0 && r.ammunition > 0 && r.simulation.roboFighters.size() > 1) {
			
			double distance = Double.MAX_VALUE;
			RoboFighter target = null;
			
			for(RoboFighter each : r.simulation.roboFighters) {
				if(each.equals(r)) continue;
				double temp = Projectile.findDistance(r.x, each.x, r.y, each.y);
				if(temp < distance) {
					distance = temp;
					target = each;
				}
			}
			
			double denominator = target.x-r.x;
			if(denominator == 0.0f) denominator += Double.MIN_NORMAL;
			double fi = Math.atan((target.y - r.y)/(target.x-r.x));
			
			if(target.x - r.x < 0) fi += Math.PI;
			
			double pStepDeltaX = Math.cos(fi);
			double pStepDeltaY = Math.sin(fi);
			
			r.simulation.projectiles.add(new Projectile(r.x + pStepDeltaX*(r.radius),
					r.y + pStepDeltaY*(r.radius), 
					pStepDeltaX, pStepDeltaY, r.color, r.simulation, r));
			
			r.ammunition--;
		}
		
		
	}
	
}
